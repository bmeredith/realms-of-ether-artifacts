{
  "language": "Solidity",
  "sources": {
    "contracts/reconstructed/BuildingStorage.sol": {
      "content": "pragma solidity 0.4.18;\n\n/// @title BuildingStorage for Realms of Ether (https://www.realmsofether.com)\n/// @notice Reconstructed by wilt.eth/@wilty_stilty\n///\n/// @notice Persistent on-chain storage contract for Buildings in Realms of Ether.\n/// Stores build costs (gold, wood, stone) and action attributes for each building,\n/// keyed by a bytes32 hash identifier. Buildings can either be mined for resources\n/// or used to recruit troups, each on a timed interval.\n///\n/// @dev RECONSTRUCTION NOTICE: The original source code for this contract was lost.\n/// This file has been reconstructed in its entirety from the deployed bytecode.\ncontract BuildingStorage {\n    address public owner;\n    bytes32[] internal buildingHashes;\n    \n    // tracks whether a given hash has been registered via createBuilding()\n    mapping(bytes32 => bool) internal exists;\n\n    // name of the building\n    mapping(bytes32 => bytes16) internal names;\n\n    // type of action the building supports (1=mine, 2=recruit)\n    mapping(bytes32 => uint256) internal action;\n    \n    // base resource yield per level when mining\n    mapping(bytes32 => uint256) internal actionRate;\n\n    // if action=1 (mine): a hash identifying the resource type (gold, wood, or stone)\n    // if action=2 (recruit): a hash identifying the troup to recruit\n    mapping(bytes32 => bytes32) internal actionValue;\n\n    // cooldown (in hours) between mining or recruiting actions\n    mapping(bytes32 => uint256) internal actionTimeout;\n    \n    // resources required to construct the building\n    mapping(bytes32 => uint256) internal gold;\n    mapping(bytes32 => uint256) internal wood;\n    mapping(bytes32 => uint256) internal stone;\n\n    // events\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function BuildingStorage() public {\n        owner = msg.sender;\n    }\n\n    function() public payable { \n        revert();\n    }\n\n    function getActionTimeout(bytes32 _buildingHash)\n        public \n        returns (uint256)\n    { \n        require(exists[_buildingHash]);\n        return actionTimeout[_buildingHash];\n    }\n\n    function createBuilding(bytes32 _buildingHash) \n        public \n    { \n        require(msg.sender == owner);\n        require(!exists[_buildingHash]);\n        \n        buildingHashes.push(_buildingHash);\n        exists[_buildingHash] = true;\n    }\n\n    function setActionValue(bytes32 _buildingHash, bytes32 _actionValue) \n        public \n    { \n        require(msg.sender == owner);\n        require(exists[_buildingHash]);\n        actionValue[_buildingHash] = _actionValue;\n    }\n\n    function setActionRate(bytes32 _buildingHash, uint256 _actionRate) \n        public \n    { \n        require(msg.sender == owner);\n        require(exists[_buildingHash]);\n        actionRate[_buildingHash] = _actionRate;\n    }\n\n    function setAction(bytes32 _buildingHash, uint256 _action) \n        public \n    { \n        require(msg.sender == owner);\n        require(exists[_buildingHash]);\n        action[_buildingHash] = _action;\n    }\n\n    function getActionRate(bytes32 _buildingHash) \n        public \n        returns (uint256)\n    { \n        require(exists[_buildingHash]);\n        return actionRate[_buildingHash];\n    }\n\n    function getName(bytes32 _buildingHash) \n        public \n        returns (bytes16)\n    { \n        require(exists[_buildingHash]);\n        return names[_buildingHash];\n    }\n\n    function getHash(uint256 _nonce) \n        public \n        returns (bytes32)\n    { \n        return buildingHashes[_nonce];\n    }\n\n    function setStone(bytes32 _buildingHash, uint256 _amount) \n        public \n    { \n        require(msg.sender == owner);\n        require(exists[_buildingHash]);\n        stone[_buildingHash] = _amount;\n    }\n\n    function setGold(bytes32 _buildingHash, uint256 _amount) \n        public \n    { \n        require(msg.sender == owner);\n        require(exists[_buildingHash]);\n        gold[_buildingHash] = _amount;\n    }\n\n    function setActionTimeout(bytes32 _buildingHash, uint256 _actionTimeout) \n        public \n    { \n        require(msg.sender == owner);\n        require(exists[_buildingHash]);\n        actionTimeout[_buildingHash] = _actionTimeout;\n    }\n\n    function setWood(bytes32 _buildingHash, uint256 _amount) \n        public \n    { \n        require(msg.sender == owner);\n        require(exists[_buildingHash]);\n        wood[_buildingHash] = _amount;\n    }\n\n    function getAction(bytes32 _buildingHash) \n        public \n        returns (uint256)\n    { \n        require(exists[_buildingHash]);\n        return action[_buildingHash];\n    }\n\n    function getWood(bytes32 _buildingHash) \n        public \n        returns (uint256)\n    { \n        require(exists[_buildingHash]);\n        return wood[_buildingHash];\n    }\n\n    function getIndexLength() \n        public \n        returns (uint256)\n    { \n        return buildingHashes.length;\n    }\n\n    function getStone(bytes32 _buildingHash) \n        public \n        returns (uint256)\n    { \n        require(exists[_buildingHash]);\n        return stone[_buildingHash];\n    }\n\n    function getGold(bytes32 _buildingHash) \n        public\n        returns (uint256)\n    { \n        require(exists[_buildingHash]);\n        return gold[_buildingHash];\n    }\n\n    function transferOwnership(address newOwner) \n        public \n    { \n        require(msg.sender == owner);\n        require(newOwner != address(0));\n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function setName(bytes32 _buildingHash, bytes16 _name) \n        public \n    { \n        require(msg.sender == owner);\n        require(exists[_buildingHash]);\n\n        names[_buildingHash] = _name;\n    }\n\n    function getActionValue(bytes32 _buildingHash) \n        public \n        returns (bytes32)\n    { \n        require(exists[_buildingHash]);\n        return actionValue[_buildingHash];\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": ["forge-std/=lib/forge-std/src/"],
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false
    },
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode.object", "evm.bytecode.sourceMap", "evm.bytecode.linkReferences", "evm.deployedBytecode.object", "evm.deployedBytecode.sourceMap", "evm.deployedBytecode.linkReferences", "evm.deployedBytecode.immutableReferences", "evm.methodIdentifiers", "metadata"]
      }
    },
    "libraries": {}
  }
}
