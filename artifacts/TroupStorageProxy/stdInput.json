{
  "language": "Solidity",
  "sources": {
    "contracts/reconstructed/TroupStorageProxy.sol": {
      "content": "pragma solidity 0.4.18;\n\nimport {ITroupStorage} from \"./interfaces/ITroupStorage.sol\";\n\n/// @title TroupStorageProxy for Realms of Ether (https://www.realmsofether.com)\n/// @notice Reconstructed by wilt.eth/@wilty_stilty\n///\n/// @notice Logic library contract for troup management in Realms of Ether.\n/// Called via delegatecall from the main game contract, allowing the main\n/// game contract to interact with TroupStorage using its own execution context.\n/// Also provides read-only convenience functions (getTroup, getCosts)\n/// that can be called directly.\n///\n/// @dev RECONSTRUCTION NOTICE: The original source code for this contract was lost.\n/// This file has been reconstructed in its entirety from the deployed bytecode.\n\ncontract TroupStorageProxy {\n    function getTroup(address _troupStorage, bytes32 _troupHash)\n        public\n        payable\n        returns (\n            bytes16,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        return (\n            ITroupStorage(_troupStorage).getName(_troupHash),\n            ITroupStorage(_troupStorage).getLife(_troupHash),\n            ITroupStorage(_troupStorage).getStrength(_troupHash),\n            ITroupStorage(_troupStorage).getIntelligence(_troupHash),\n            ITroupStorage(_troupStorage).getDexterity(_troupHash)\n        );\n    }\n\n    function createTroup(\n        address _troupStorage, \n        bytes32 _troupHash, \n        bytes16 _name, \n        uint256 _life, \n        uint256 _strength, \n        uint256 _intelligence, \n        uint256 _dexterity, \n        uint256 _gold, \n        uint256 _wood, \n        uint256 _stone\n    ) \n        public \n        payable\n    { \n        ITroupStorage(_troupStorage).createTroup(_troupHash);\n        ITroupStorage(_troupStorage).setName(_troupHash, _name);\n        ITroupStorage(_troupStorage).setLife(_troupHash, _life);\n        ITroupStorage(_troupStorage).setStrength(_troupHash, _strength);\n        ITroupStorage(_troupStorage).setIntelligence(_troupHash, _intelligence);\n        ITroupStorage(_troupStorage).setDexterity(_troupHash, _dexterity);\n        ITroupStorage(_troupStorage).setGold(_troupHash, _gold);\n        ITroupStorage(_troupStorage).setWood(_troupHash, _wood);\n        ITroupStorage(_troupStorage).setStone(_troupHash, _stone);\n    }\n\n    function upgrade(address proxy, address implementation) \n        public \n        payable\n    { \n        ITroupStorage(proxy).transferOwnership(implementation);\n    }\n\n    function getHash(address _troupStorage, uint256 _nonce) \n        public \n        payable\n        returns (bytes32)\n    {\n        return ITroupStorage(_troupStorage).getHash(_nonce);\n    }\n\n    function getIndexLength(address _troupStorage) \n        public \n        payable\n        returns (uint256)\n    { \n        return ITroupStorage(_troupStorage).getIndexLength();\n    }\n\n    /// @dev Returns (gold, stone, wood) â€” note stone and wood are swapped\n    /// compared to the (gold, wood, stone) ordering used elsewhere in the codebase\n    function getCosts(address _troupStorage, bytes32 _troupHash) \n        public \n        payable\n        returns (uint256, uint256, uint256)\n    { \n        return (\n            ITroupStorage(_troupStorage).getGold(_troupHash),\n            ITroupStorage(_troupStorage).getStone(_troupHash),\n            ITroupStorage(_troupStorage).getWood(_troupHash)\n        );\n    }\n\n    function() public payable {\n        revert();\n    }\n}"
    },
    "contracts/reconstructed/interfaces/ITroupStorage.sol": {
      "content": "pragma solidity 0.4.18;\n\ninterface ITroupStorage {\n    function createTroup(bytes32 _troupHash) external;\n    function setName(bytes32 _troupHash, bytes16 _name) external;\n    function setLife(bytes32 _troupHash, uint256 _amount) external;\n    function setStrength(bytes32 _troupHash, uint256 _amount) external;\n    function setIntelligence(bytes32 _troupHash, uint256 _amount) external;\n    function setDexterity(bytes32 _troupHash, uint256 _amount) external;\n    function setGold(bytes32 _troupHash, uint256 _amount) external;\n    function setWood(bytes32 _troupHash, uint256 _amount) external;\n    function setStone(bytes32 _troupHash, uint256 _amount) external;\n    function getName(bytes32 _troupHash) external returns (bytes16);\n    function getLife(bytes32 _troupHash) external returns (uint256);\n    function getStrength(bytes32 _troupHash) external returns (uint256);\n    function getIntelligence(bytes32 _troupHash) external returns (uint256);\n    function getDexterity(bytes32 _troupHash) external returns (uint256);\n    function getGold(bytes32 _troupHash) external returns (uint256);\n    function getWood(bytes32 _troupHash) external returns (uint256);\n    function getStone(bytes32 _troupHash) external returns (uint256);\n    function getHash(uint256 _nonce) external returns (bytes32);\n    function getIndexLength() external returns (uint256);\n    function transferOwnership(address newOwner) external;\n}"
    }
  },
  "settings": {
    "remappings": ["forge-std/=lib/forge-std/src/"],
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": false
    },
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode.object", "evm.bytecode.sourceMap", "evm.bytecode.linkReferences", "evm.deployedBytecode.object", "evm.deployedBytecode.sourceMap", "evm.deployedBytecode.linkReferences", "evm.deployedBytecode.immutableReferences", "evm.methodIdentifiers", "metadata"]
      }
    },
    "libraries": {}
  }
}
